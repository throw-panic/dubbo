
# dubbo 协议

说明：
1. Dubbo 缺省协议采用单一长连接和 NIO 异步通讯，适合于小数据量大并发的服务调用，
    以及服务消费者机器数远大于服务提供者机器数的情况。
2. 反之，Dubbo 缺省协议不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。


# 常见问题

## （1）为什么要消费者比提供者个数多? {消费者consumer：提供者provider = 20：1 }

因 dubbo 协议采用单一长连接，假设网络为千兆网卡 （1024Mbit=128MByte），
根据测试经验数据每条连接最多只能压满 7MByte(不同的环境可能不一样，供参考)，
理论上 1 个服务提供者需要 20 个服务消费者才能压满网卡。


## （2）为什么不能传大包?

因dubbo 协议采用单一长连接，如果每次请求的数据包大小为500KByte，假设网络为千兆网卡（1024Mbit=128MByte），
每条连接最大 7MByte(不同的环境可能不一样，供参考)，
单个服务提供者的 TPS(每秒处理事务数)最大为：128MByte / 500KByte = 262。
单个消费者调用单个服务提供者的 TPS(每秒处理事务数)最大为：7MByte / 500KByte = 14。
如果能接受，可以考虑使用，否则网络将成为瓶颈。


## 为什么采用异步单一长连接?

因为服务的现状大都是服务提供者少，通常只有几台机器，而服务的消费者多，可能整个网站都在访问该服务，
比如 Morgan 的提供者只有 6 台提供者，却有上百台消费者，每天有 1.5 亿次调用，
如果采用常规的 hessian 服务，服务提供者很容易就被压跨，通过单一连接，保证单一消费者不会压死提供者，
长连接，减少连接握手验证等，并使用异步 IO，复用线程池，防止 C10K 问题。

- C10K问题：如何突破单机性能是高性能网络编程必须要面对的问题，进而这些局限和问题就统称为C10K问题。
- C10K问题的本质上是操作系统的问题，传统的同步阻塞I/O模型处理方式都是requests per second。
    当创建的进程或线程多了，数据拷贝频繁（缓存I/O、内核将数据拷贝到用户进程空间、阻塞，
    进程/线程上下文切换消耗大， 导致操作系统崩溃，这就是C10K问题的本质。

